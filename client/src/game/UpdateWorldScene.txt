import Phaser from 'phaser'

// --- Naming + paths (align with ASSETS_DROPZONE_README + REQUIREMENTS) ---
const DEFAULT_MAP_FILE = 'main-floor.json'
const MAP_BASE_URL = '/assets/maps/floors/'
const TILESET_KEY = 'neumont_tileset_32'
const TILESET_IMAGE_URL = '/assets/tilesets/neumont/neumont_tileset_32.png'
const TILESET_EXPECTED_NAME = 'neumont_tileset_32'
const TILE_SIZE = 32

const PLAYER_TEXTURE_KEY = 'player_placeholder'
const DEV_MODE = typeof import.meta !== 'undefined' && !!import.meta.env?.DEV
const DEBUG_OVERLAYS_DEFAULT = false
const MIN_CAMERA_ZOOM = 0.5
const MAX_CAMERA_ZOOM = 1

// --- Visual polish toggles ---
const ENABLE_AUTO_DECALS = true
const AUTO_DECAL_DENSITY = 0.035

// Tileset-local tile indices for decals (NOT global gids). Fill these in once you know them.
// Example: if your tileset has floor tiles at local 0..7, decals might start at 40+.
const DECAL_TILE_LOCAL_IDS: number[] = [
  // TODO: replace with real tile indices from neumont_tileset_32
  // 40, 41, 42, 43
]

// The first 8 tiles are reserved for floor variants (tools/variantFloorTiles.js assumes 8 variants) :contentReference[oaicite:11]{index=11}
const FLOOR_VARIANT_LOCAL_MAX_EXCLUSIVE = 8
const FLOOR_LAYER_NAMES = ['ground', 'floor']

type SpawnPoint = { x: number; y: number }
type PortalDefinition = { targetMap: string; targetSpawn?: string }

export default class WorldScene extends Phaser.Scene {
  private cursors: Phaser.Types.Input.Keyboard.CursorKeys | null = null
  private wasd:
    | {
        W: Phaser.Input.Keyboard.Key
        A: Phaser.Input.Keyboard.Key
        S: Phaser.Input.Keyboard.Key
        D: Phaser.Input.Keyboard.Key
      }
    | null = null
  private player?: Phaser.Types.Physics.Arcade.SpriteWithDynamicBody
  private tileLayers: Phaser.Tilemaps.TilemapLayer[] = []
  private portalZones: Phaser.GameObjects.Zone[] = []
  private colliders: Phaser.Physics.Arcade.Collider[] = []
  private currentMapFile: string | null = null
  private currentMap: Phaser.Tilemaps.Tilemap | null = null
  private isTransitioning = false
  private portalCooldownUntil = 0
  private playerTextureReady = false
  private resizeHandler: (() => void) | null = null
  private debugEnabled = DEBUG_OVERLAYS_DEFAULT
  private debugGraphics: Phaser.GameObjects.Graphics | null = null
  private debugToggleBound = false

  constructor() {
    super('world')
  }

  preload() {
    this.load.image(TILESET_KEY, TILESET_IMAGE_URL)
    this.load.tilemapTiledJSON(
      this.mapKey(DEFAULT_MAP_FILE),
      this.mapUrl(DEFAULT_MAP_FILE)
    )
  }

  create() {
    this.ensureInputReady()
    this.bindDebugToggle()

    this.loadMap(DEFAULT_MAP_FILE)
  }

  update() {
    if (!this.player) return

    const speed = 200
    const body = this.player.body
    body.setVelocity(0, 0)

    const left = this.cursors?.left?.isDown || this.wasd?.A?.isDown
    const right = this.cursors?.right?.isDown || this.wasd?.D?.isDown
    const up = this.cursors?.up?.isDown || this.wasd?.W?.isDown
    const down = this.cursors?.down?.isDown || this.wasd?.S?.isDown

    if (left) body.setVelocityX(-speed)
    if (right) body.setVelocityX(speed)
    if (up) body.setVelocityY(-speed)
    if (down) body.setVelocityY(speed)

    body.velocity.normalize().scale(speed)
  }

  private mapKey(fileName: string) {
    return `map:${fileName}`
  }

  private mapUrl(fileName: string) {
    return `${MAP_BASE_URL}${fileName}`
  }

  private loadMap(fileName: string, spawnName?: string) {
    const mapKey = this.mapKey(fileName)

    if (this.cache.tilemap.has(mapKey)) {
      this.buildMap(mapKey, fileName, spawnName)
      return
    }

    this.load.tilemapTiledJSON(mapKey, this.mapUrl(fileName))
    this.load.once(Phaser.Loader.Events.COMPLETE, () => {
      this.buildMap(mapKey, fileName, spawnName)
    })
    this.load.once(
      Phaser.Loader.Events.FILE_LOAD_ERROR,
      (file: Phaser.Loader.File) => {
        const source = file?.src ?? fileName
        console.error(`Failed to load map JSON from ${source}.`)
        this.isTransitioning = false
      }
    )

    if (!this.load.isLoading()) {
      this.load.start()
    }
  }

  private buildMap(mapKey: string, fileName: string, spawnName?: string) {
    this.cleanupMap()
    this.currentMapFile = fileName

    const map = this.make.tilemap({ key: mapKey })
    this.currentMap = map
    const tiledTilesetName =
      map.tilesets.find((set) => set.name === TILESET_EXPECTED_NAME)?.name ??
      map.tilesets[0]?.name

    if (!tiledTilesetName) {
      console.error(`No tilesets found in map "${mapKey}".`)
      this.isTransitioning = false
      return
    }

    if (tiledTilesetName !== TILESET_EXPECTED_NAME) {
      console.warn(
        `Tileset name mismatch. Expected "${TILESET_EXPECTED_NAME}", but map uses "${tiledTilesetName}".`
      )
    }

    const tileset = map.addTilesetImage(
      tiledTilesetName,
      TILESET_KEY,
      TILE_SIZE,
      TILE_SIZE,
      0,
      0
    )

    if (!tileset) {
      const available = map.tilesets.map((set) => set.name)
      console.error(
        `Tileset name mismatch. Expected "${TILESET_EXPECTED_NAME}", but map contains: ${
          available.length ? available.join(', ') : 'none'
        }.`
      )
      this.isTransitioning = false
      return
    }

    // Build layers + enforce consistent depth
    map.layers.forEach((layerData) => {
      const layerType = (layerData as { type?: string }).type
      if (layerType && layerType !== 'tilelayer') return

      const layer = map.createLayer(layerData.name, tileset)
      if (!layer) return

      layer.setPosition(0, 0)
      layer.setDepth(this.getLayerDepth(layerData.name))
      this.applyCollision(layer)
      this.tileLayers.push(layer)
    })

    if (this.tileLayers.length === 0) {
      console.error(`No tile layers found in map "${mapKey}".`)
      this.isTransitioning = false
      return
    }

    const spawn = this.findSpawnPoint(map, spawnName)
    this.ensurePlayer(spawn)
    this.ensureInputReady()

    if (ENABLE_AUTO_DECALS) {
      this.addAutoDecals(map, tileset, fileName)
    }

    const player = this.player
    if (player) {
      this.tileLayers.forEach((layer) => {
        this.colliders.push(this.physics.add.collider(player, layer))
      })
    }

    this.physics.world.setBounds(0, 0, map.widthInPixels, map.heightInPixels)
    this.configureCamera(map)
    this.createPortals(map)
    this.refreshDebugOverlays(map)
    this.logFloorLoad(fileName, spawnName, spawn, map)

    this.isTransitioning = false
  }

  private ensureInputReady() {
    if (!this.input.keyboard) return
    if (!this.cursors) {
      this.cursors = this.input.keyboard.createCursorKeys()
    }
    if (!this.wasd) {
      this.wasd = this.input.keyboard.addKeys('W,A,S,D') as {
        W: Phaser.Input.Keyboard.Key
        A: Phaser.Input.Keyboard.Key
        S: Phaser.Input.Keyboard.Key
        D: Phaser.Input.Keyboard.Key
      }
    }
  }

  private bindDebugToggle() {
    if (this.debugToggleBound) return
    if (!this.input.keyboard) return
    this.debugToggleBound = true
    this.input.keyboard.on('keydown-F3', () => {
      this.setDebugOverlaysEnabled(!this.debugEnabled)
    })
  }

  private ensurePlayer(spawn: SpawnPoint) {
    const playerSize = 32
    const colliderSize = 26

    if (!this.playerTextureReady) {
      const playerGfx = this.add.graphics()
      playerGfx.fillStyle(0x38bdf8, 1)
      playerGfx.fillRect(0, 0, playerSize, playerSize)
      playerGfx.generateTexture(PLAYER_TEXTURE_KEY, playerSize, playerSize)
      playerGfx.destroy()
      this.playerTextureReady = true
    }

    if (!this.player) {
      this.player = this.physics.add
        .sprite(spawn.x, spawn.y, PLAYER_TEXTURE_KEY)
        .setCollideWorldBounds(true)
    } else {
      this.player.setPosition(spawn.x, spawn.y)
      this.player.body.reset(spawn.x, spawn.y)
    }

    this.player.setSize(colliderSize, colliderSize)
    this.player.setOffset(
      (playerSize - colliderSize) / 2,
      playerSize - colliderSize
    )
  }

  private createPortals(map: Phaser.Tilemaps.Tilemap) {
    const portalLayer = map.getObjectLayer('Portals')
    const player = this.player
    const objectsLayer = map.getObjectLayer('Objects')
    const portalObjects =
      portalLayer?.objects ??
      objectsLayer?.objects?.filter((obj) =>
        (obj.type ?? obj.name ?? '')
          .toString()
          .toLowerCase()
          .includes('portal')
      ) ??
      []

    if (!portalObjects.length || !player) return

    portalObjects.forEach((obj) => {
      if (!obj.width || !obj.height) return
      const props = this.getObjectProperties(obj)
      const targetMap = props.targetMap
      const targetSpawn = props.targetSpawn

      if (typeof targetMap !== 'string' || targetMap.length === 0) {
        console.error(
          `Portal is missing a valid targetMap (object: "${obj.name ?? 'unnamed'}").`
        )
        return
      }

      const resolvedMap = this.resolveMapFile(targetMap)

      const zone = this.add.zone(
        (obj.x ?? 0) + obj.width / 2,
        (obj.y ?? 0) + obj.height / 2,
        obj.width,
        obj.height
      )
      this.physics.add.existing(zone, true)
      this.portalZones.push(zone)

      const collider = this.physics.add.overlap(
        player,
        zone,
        () => {
          this.tryPortalTransition({
            targetMap: resolvedMap,
            targetSpawn:
              typeof targetSpawn === 'string' ? targetSpawn : undefined,
          })
        },
        undefined,
        this
      )
      this.colliders.push(collider)
    })
  }

  private tryPortalTransition(portal: PortalDefinition) {
    if (this.isTransitioning) return
    if (this.time.now < this.portalCooldownUntil) return

    this.isTransitioning = true
    this.portalCooldownUntil = this.time.now + 500

    this.loadMap(portal.targetMap, portal.targetSpawn)
  }

  private cleanupMap() {
    this.colliders.forEach((collider) => collider.destroy())
    this.colliders = []
    this.portalZones.forEach((zone) => zone.destroy())
    this.portalZones = []
    this.tileLayers.forEach((layer) => layer.destroy())
    this.tileLayers = []
    this.currentMap = null
    this.clearDebugOverlays()
  }

  private resolveMapFile(targetMap: string) {
    const normalized = targetMap.trim()
    const baseName =
      normalized.replace(/\\/g, '/').split('/').pop() ?? normalized
    const lower = baseName.toLowerCase()
    const aliasMap: Record<string, string> = {
      main: 'main-floor.json',
      'main-floor': 'main-floor.json',
      'main-floor.json': 'main-floor.json',
      'neumont_main.json': 'main-floor.json',
      basement: 'basement-floor.json',
      'basement-floor': 'basement-floor.json',
      'basement-floor.json': 'basement-floor.json',
      'neumont_basement.json': 'basement-floor.json',
      floor2: 'floor2.json',
      'floor2.json': 'floor2.json',
      'neumont_floor2.json': 'floor2.json',
      floor3: 'floor3.json',
      'floor3.json': 'floor3.json',
      'neumont_floor3.json': 'floor3.json',
    }

    if (aliasMap[lower]) return aliasMap[lower]
    if (lower.endsWith('.json')) return baseName
    return `${baseName}.json`
  }

  private getObjectProperties(
    obj: Phaser.Types.Tilemaps.TiledObject
  ): Record<string, unknown> {
    const props: Record<string, unknown> = {}
    const raw = obj.properties

    if (Array.isArray(raw)) {
      raw.forEach((prop) => {
        if (prop && typeof prop.name === 'string') {
          props[prop.name] = prop.value
        }
      })
    } else if (raw && typeof raw === 'object') {
      Object.assign(props, raw)
    }

    return props
  }

  private findSpawnPoint(
    map: Phaser.Tilemaps.Tilemap,
    spawnName?: string
  ): SpawnPoint {
    const spawnLayer = map.getObjectLayer('Spawns')
    const objectsLayer = map.getObjectLayer('Objects')
    const spawnObjects =
      spawnLayer?.objects ??
      objectsLayer?.objects?.filter((obj) =>
        (obj.type ?? obj.name ?? '').toString().toLowerCase().includes('spawn')
      ) ??
      []

    if (spawnObjects.length) {
      const normalizedSpawnName = spawnName?.toLowerCase()
      const defaultSpawn = spawnObjects.find(
        (obj) => obj.name?.toLowerCase() === 'spawn_default'
      )
      let spawnObject =
        normalizedSpawnName &&
        spawnObjects.find(
          (obj) => obj.name?.toLowerCase() === normalizedSpawnName
        )

      if (!spawnObject && normalizedSpawnName) {
        if (defaultSpawn) {
          console.error(
            `!!! Spawn "${spawnName}" not found in map "${
              this.currentMapFile ?? 'unknown'
            }". Falling back to spawn_default.`
          )
          spawnObject = defaultSpawn
        } else {
          console.error(
            `!!! Spawn "${spawnName}" not found in map "${
              this.currentMapFile ?? 'unknown'
            }". Falling back to a safe default spawn.`
          )
          return {
            x: map.tileWidth * 2,
            y: map.tileHeight * 2,
          }
        }
      }

      if (!spawnObject) {
        spawnObject = defaultSpawn ?? spawnObjects[0]
      }

      const x = spawnObject.x ?? map.tileWidth
      const y = spawnObject.y ?? map.tileHeight
      const width = spawnObject.width ?? 0
      const height = spawnObject.height ?? 0

      if (spawnObject.point) {
        return { x, y }
      }

      return { x: x + width / 2, y: y + height / 2 }
    }

    console.error(
      `!!! No spawn objects found in map "${this.currentMapFile ?? 'unknown'}". ` +
        'Falling back to a safe default spawn.'
    )
    return {
      x: map.tileWidth * 2,
      y: map.tileHeight * 2,
    }
  }

  private logFloorLoad(
    fileName: string,
    spawnName: string | undefined,
    spawn: SpawnPoint,
    map: Phaser.Tilemaps.Tilemap
  ) {
    if (!DEV_MODE) return
    const camera = this.cameras.main
    const player = this.player
    console.debug('[WorldScene] Floor loaded', {
      floor: fileName,
      spawnName: spawnName ?? 'spawn_default',
      spawn,
      player: { x: player?.x ?? null, y: player?.y ?? null },
      camera: { scrollX: camera.scrollX, scrollY: camera.scrollY },
      mapSize: { width: map.widthInPixels, height: map.heightInPixels },
    })
  }

  private setDebugOverlaysEnabled(enabled: boolean) {
    this.debugEnabled = enabled
    if (!enabled) {
      this.clearDebugOverlays()
      return
    }
    if (this.currentMap) {
      this.refreshDebugOverlays(this.currentMap)
    }
  }

  private clearDebugOverlays() {
    if (this.debugGraphics) {
      this.debugGraphics.clear()
      this.debugGraphics.setVisible(false)
    }
  }

  private refreshDebugOverlays(map: Phaser.Tilemaps.Tilemap) {
    if (!this.debugEnabled) return
    if (!this.debugGraphics) {
      this.debugGraphics = this.add.graphics()
    }
    const graphics = this.debugGraphics
    graphics.clear()
    graphics.setVisible(true)
    graphics.setDepth(1000)

    graphics.lineStyle(1, 0xff4d4d, 0.6)
    this.tileLayers.forEach((layer) => {
      layer.forEachTile((tile) => {
        if (!tile?.collides) return
        graphics.strokeRect(tile.pixelX, tile.pixelY, tile.width, tile.height)
      })
    })

    graphics.lineStyle(2, 0x38bdf8, 0.8)
    this.portalZones.forEach((zone) => {
      graphics.strokeRect(
        zone.x - zone.width / 2,
        zone.y - zone.height / 2,
        zone.width,
        zone.height
      )
    })

    graphics.lineStyle(2, 0xfacc15, 0.4)
    graphics.strokeRect(0, 0, map.widthInPixels, map.heightInPixels)
  }

  private applyCollision(layer: Phaser.Tilemaps.TilemapLayer) {
    layer.setCollisionByProperty({ collision: true })
    layer.setCollisionByProperty({ collides: true })
    let hasCollision = false
    layer.forEachTile((tile) => {
      if (tile.collides) {
        hasCollision = true
      }
    })

    const layerName = layer.layer.name.toLowerCase()
    const shouldForceCollision = ['walls', 'wall', 'collision'].some((label) =>
      layerName.includes(label)
    )

    if (!hasCollision && shouldForceCollision) {
      layer.setCollisionByExclusion([-1])
    }

    if (layerName.includes('collision')) {
      layer.setVisible(false)
    }
  }

  private getLayerDepth(name: string): number {
    const n = (name ?? '').toLowerCase()

    // collision invisible anyway, but keep it low
    if (n.includes('collision')) return -100

    // floor/ground at the bottom
    if (n.includes('ground') || n.includes('floor')) return 0

    // decals/details above floor
    if (n.includes('decal') || n.includes('detail') || n.includes('trim'))
      return 10

    // walls/buildings above decals
    if (n.includes('wall') || n.includes('building') || n.includes('structure'))
      return 20

    // foreground/overhead highest
    if (n.includes('foreground') || n.includes('overhead') || n.includes('top'))
      return 30

    // default mid
    return 15
  }

  private addAutoDecals(
    map: Phaser.Tilemaps.Tilemap,
    tileset: Phaser.Tilemaps.Tileset,
    fileName: string
  ) {
    const decals = this.getValidDecalIds(tileset)
    if (!decals.length) return

    const floorLayer = this.tileLayers.find((layer) =>
      this.isFloorLayerName(layer.layer.name)
    )
    if (!floorLayer) return

    // Collect collision positions across all layers
    const colliding = new Set<string>()
    this.tileLayers.forEach((layer) => {
      layer.forEachTile((tile) => {
        if (tile?.collides) colliding.add(`${tile.x},${tile.y}`)
      })
    })

    const isNearCollision = (x: number, y: number) => {
      for (let dy = -1; dy <= 1; dy += 1) {
        for (let dx = -1; dx <= 1; dx += 1) {
          if (dx === 0 && dy === 0) continue
          if (colliding.has(`${x + dx},${y + dy}`)) return true
        }
      }
      return false
    }

    // Deterministic RNG per-map
    const seed = this.hashStringToInt(fileName)
    const rng = this.makeMulberry32(seed)

    // Create a blank decals layer above floor but below walls
    const decalsLayer = map.createBlankLayer(
      'Decals_Auto',
      tileset,
      0,
      0,
      map.width,
      map.height,
      map.tileWidth,
      map.tileHeight
    )
    if (!decalsLayer) return
    decalsLayer.setDepth(this.getLayerDepth('decals'))
    this.tileLayers.push(decalsLayer)

    for (let y = 0; y < map.height; y += 1) {
      for (let x = 0; x < map.width; x += 1) {
        const base = floorLayer.getTileAt(x, y)
        if (!base) continue

        // Only decorate floor-variant tiles (local 0..7)
        const localIndex = base.index // local to tileset in Phaser
        if (
          localIndex < 0 ||
          localIndex >= FLOOR_VARIANT_LOCAL_MAX_EXCLUSIVE
        )
          continue

        if (colliding.has(`${x},${y}`)) continue
        if (isNearCollision(x, y)) continue
        if (rng() > AUTO_DECAL_DENSITY) continue

        const decalLocal = decals[Math.floor(rng() * decals.length)]
        decalsLayer.putTileAt(decalLocal, x, y)
      }
    }
  }

  private getValidDecalIds(tileset: Phaser.Tilemaps.Tileset): number[] {
    const total =
      (tileset as { total?: number }).total ??
      (tileset as { tileCount?: number }).tileCount

    return DECAL_TILE_LOCAL_IDS.filter((id) => {
      if (!Number.isInteger(id) || id < 0) return false
      if (typeof total === 'number') return id < total
      return true
    })
  }

  private isFloorLayerName(name: string) {
    const lowered = (name ?? '').toLowerCase()
    return FLOOR_LAYER_NAMES.some((label) => lowered.includes(label))
  }

  private hashStringToInt(str: string): number {
    let h = 2166136261
    for (let i = 0; i < str.length; i += 1) {
      h ^= str.charCodeAt(i)
      h = Math.imul(h, 16777619)
    }
    return h >>> 0
  }

  private makeMulberry32(seed: number) {
    let t = seed >>> 0
    return () => {
      t += 0x6d2b79f5
      let r = Math.imul(t ^ (t >>> 15), 1 | t)
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r)
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296
    }
  }

  private configureCamera(map: Phaser.Tilemaps.Tilemap) {
    const camera = this.cameras.main
    const mapWidth = map.widthInPixels
    const mapHeight = map.heightInPixels

    camera.setBounds(0, 0, mapWidth, mapHeight)
    if (this.player) {
      camera.startFollow(this.player, true, 0.1, 0.1)
    }
    camera.setBackgroundColor('#0f172a')
    camera.roundPixels = true

    const updateZoom = () => {
      const scaleW = this.scale.width
      const scaleH = this.scale.height
      const fitZoom = Math.min(scaleW / mapWidth, scaleH / mapHeight)
      const zoom = Phaser.Math.Clamp(fitZoom, MIN_CAMERA_ZOOM, MAX_CAMERA_ZOOM)
      camera.setZoom(zoom)
    }

    updateZoom()

    if (this.resizeHandler) {
      this.scale.off('resize', this.resizeHandler)
    }

    this.resizeHandler = () => {
      updateZoom()
    }

    this.scale.on('resize', this.resizeHandler)
  }
}
